<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Автофиксация и обрезка документа</title>
  <style>
    body {
      margin: 0;
      background: #000;
      color: white;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }
    #videoContainer {
      position: relative;
      width: 100%;
      max-width: 400px;
      aspect-ratio: 4 / 3;
    }
    video, canvas {
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 8px;
    }
    p {
      margin-top: 10px;
    }
    img {
      margin-top: 20px;
      max-width: 90%;
      border: 2px solid #00ff00;
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <div id="videoContainer">
    <video id="video" autoplay playsinline></video>
    <canvas id="overlay"></canvas>
  </div>
  <p id="status">Ожидание документа...</p>

  <!-- OpenCV -->
  <script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady();"></script>

  <script>
    const video = document.getElementById("video");
    const canvas = document.getElementById("overlay");
    const ctx = canvas.getContext("2d");
    const statusEl = document.getElementById("status");
    let autoCaptured = false;

    navigator.mediaDevices.getUserMedia({ video: true }).then(stream => {
      video.srcObject = stream;
    });

    function onOpenCvReady() {
      cv['onRuntimeInitialized'] = () => {
        console.log('OpenCV готов');
        video.addEventListener("loadedmetadata", () => {
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          drawGuide();
          setTimeout(processFrame, 500);
        });
      };
    }

    function drawGuide() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = "#00FF00";
      ctx.lineWidth = 3;

      const rectWidth = canvas.width * 0.8;
      const rectHeight = rectWidth * 0.63;
      const rectX = (canvas.width - rectWidth) / 2;
      const rectY = (canvas.height - rectHeight) / 2;

      ctx.strokeRect(rectX, rectY, rectWidth, rectHeight);
    }

    function processFrame() {
      if (autoCaptured) return;

      const tempCanvas = document.createElement("canvas");
      tempCanvas.width = video.videoWidth;
      tempCanvas.height = video.videoHeight;
      const tempCtx = tempCanvas.getContext("2d");
      tempCtx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);

      const src = cv.imread(tempCanvas);
      let gray = new cv.Mat();
      let blur = new cv.Mat();
      let edges = new cv.Mat();
      let contours = new cv.MatVector();
      let hierarchy = new cv.Mat();

      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
      cv.GaussianBlur(gray, blur, new cv.Size(5, 5), 0);
      cv.Canny(blur, edges, 75, 200);
      cv.findContours(edges, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

      let largestQuad = null;
      let maxArea = 0;

      for (let i = 0; i < contours.size(); i++) {
        let cnt = contours.get(i);
        let approx = new cv.Mat();
        cv.approxPolyDP(cnt, approx, 0.02 * cv.arcLength(cnt, true), true);
        let area = cv.contourArea(cnt);
        if (approx.rows === 4 && area > 10000 && area > maxArea) {
          largestQuad = approx.clone();
          maxArea = area;
        }
        approx.delete();
      }

      if (largestQuad) {
        statusEl.textContent = "Документ найден! Обрезаем...";
        autoCaptured = true;
        cropDocument(src, largestQuad);
        largestQuad.delete();
      } else {
        statusEl.textContent = "Ожидание документа...";
        setTimeout(processFrame, 500);
      }

      // Очистка
      src.delete(); gray.delete(); blur.delete(); edges.delete(); contours.delete(); hierarchy.delete();
    }

    function cropDocument(src, quad) {
      const pts = [];
      for (let i = 0; i < 4; i++) {
        pts.push({
          x: quad.intAt(i, 0),
          y: quad.intAt(i, 1)
        });
      }

      // Сортируем точки по часовой стрелке
      pts.sort((a, b) => a.x + a.y - (b.x + b.y));
      const [tl, tr, br, bl] = pts;

      const widthA = Math.hypot(br.x - bl.x, br.y - bl.y);
      const widthB = Math.hypot(tr.x - tl.x, tr.y - tl.y);
      const maxWidth = Math.max(widthA, widthB);

      const heightA = Math.hypot(tr.x - br.x, tr.y - br.y);
      const heightB = Math.hypot(tl.x - bl.x, tl.y - bl.y);
      const maxHeight = Math.max(heightA, heightB);

      const srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
        tl.x, tl.y,
        tr.x, tr.y,
        br.x, br.y,
        bl.x, bl.y
      ]);
      const dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
        0, 0,
        maxWidth, 0,
        maxWidth, maxHeight,
        0, maxHeight
      ]);

      const M = cv.getPerspectiveTransform(srcTri, dstTri);
      const dst = new cv.Mat();
      const dsize = new cv.Size(maxWidth, maxHeight);
      cv.warpPerspective(src, dst, M, dsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());

      cv.imshow(canvas, dst); // Отображаем обрезанное на том же canvas
      statusEl.textContent = "Документ обрезан!";

      // Конвертация в изображение
      const img = new Image();
      img.src = canvas.toDataURL("image/jpeg");
      document.body.appendChild(img);

      // Очистка
      srcTri.delete(); dstTri.delete(); M.delete(); dst.delete();
    }
  </script>
</body>
</html>
