<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>Верификация документа</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, viewport-fit=cover"
    />
    <!-- Подключаем OpenCV.js -->
    <script async src="https://docs.opencv.org/4.5.5/opencv.js" onload="onOpenCvReady()"></script>
    <link rel="stylesheet" href="style.css">
    <style>
      /* Стиль для неактивной кнопки спуска */
      .btn-circle.disabled {
        background-color: #888;
        cursor: not-allowed;
        opacity: 0.5;
      }
    </style>
  </head>
  <body>
    <div id="launchContainer">
      <button onclick="startCamera()">Запустить камеру</button>
    </div>

    <div id="videoContainer">
      <div id="status">Поместите документ в пределах белой рамки</div>
      <video id="video" autoplay playsinline></video>
      <div id="overlay-darken"></div>
      <div id="frame"></div>
      <div id="buttons">
        <button class="btn-switch" onclick="switchCamera()"></button>
        <button class="btn-circle disabled" onclick="takePhoto()"></button>
      </div>
    </div>

    <div id="previewContainer">
      <img id="previewImage" alt="Preview" />
      <a id="downloadButton" href="#" download="captured-photo.jpg">Скачать фото</a>
      <button id="redoButton" onclick="retakePhoto()">Переделать снимок</button>
    </div>

    <script>
      let stream;
      let currentFacingMode = "environment";
      const video = document.getElementById("video");
      const frame = document.getElementById("frame");
      const launchContainer = document.getElementById("launchContainer");
      const videoContainer = document.getElementById("videoContainer");
      const previewContainer = document.getElementById("previewContainer");
      const previewImage = document.getElementById("previewImage");
      const statusEl = document.getElementById("status");
      const downloadButton = document.getElementById("downloadButton");
      const captureButton = document.querySelector(".btn-circle");
      let openCvLoaded = false;
      let documentDetected = false;
      let inactivityTimer = null;
      const INACTIVITY_TIMEOUT = 30000; // 30 секунд

      // Сбрасываем таймер бездействия при активности
      function resetInactivityTimer() {
        if (inactivityTimer) clearTimeout(inactivityTimer);
        inactivityTimer = setTimeout(stopCameraDueToInactivity, INACTIVITY_TIMEOUT);
      }

      // Останавливаем камеру и возвращаем начальный экран
      function stopCameraDueToInactivity() {
        if (stream) {
          stream.getTracks().forEach((track) => track.stop());
          stream = null;
        }
        videoContainer.style.display = "none";
        previewContainer.style.display = "none";
        launchContainer.style.display = "flex";
        statusEl.textContent = "Камера отключена из-за бездействия";
        documentDetected = false;
        frame.classList.remove("detected");
        captureButton.classList.add("disabled");
      }

      // Проверяем загрузку OpenCV.js
      function onOpenCvReady() {
        openCvLoaded = true;
        console.log("OpenCV.js загружен");
        startDocumentDetection();
      }

      async function startCamera(facingModeInput) {
        console.log("Запуск камеры");
        resetInactivityTimer();
        const facingMode = facingModeInput || currentFacingMode || "environment";
        if (stream) stream.getTracks().forEach((track) => track.stop());
        try {
          stream = await navigator.mediaDevices.getUserMedia({
            video: {
              facingMode,
              width: { ideal: 3840 },
              height: { ideal: 2160 },
            },
            audio: false,
          });
          video.srcObject = stream;
          videoContainer.style.display = "flex";
          launchContainer.style.display = "none";
          previewContainer.style.display = "none";
          statusEl.textContent = "Поместите документ в пределах белой рамки";
          currentFacingMode = facingMode;
          captureButton.classList.add("disabled");

          await new Promise((resolve) => {
            video.onloadedmetadata = () => resolve();
          });

          if (openCvLoaded) startDocumentDetection();
        } catch (err) {
          console.warn("Ошибка камеры:", err);
          if (
            facingMode === "environment" &&
            err.name === "OverconstrainedError"
          ) {
            return startCamera("user");
          }
          statusEl.textContent = "Ошибка запуска камеры: " + err.message;
        }
      }

      function switchCamera() {
        console.log("Переключение камеры");
        resetInactivityTimer();
        const nextMode = currentFacingMode === "user" ? "environment" : "user";
        startCamera(nextMode);
      }

      function detectDocument() {
        if (!openCvLoaded) return;

        const canvas = document.createElement("canvas");
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

        let src = cv.imread(canvas);
        let gray = new cv.Mat();
        let blurred = new cv.Mat();
        let edges = new cv.Mat();
        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();

        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
        cv.GaussianBlur(gray, blurred, new cv.Size(3, 3), 0);
        cv.Canny(blurred, edges, 30, 100);
        cv.findContours(
          edges,
          contours,
          hierarchy,
          cv.RETR_EXTERNAL,
          cv.CHAIN_APPROX_SIMPLE
        );

        // Вычисляем координаты рамки #frame в пикселях видео
        const frameRect = frame.getBoundingClientRect();
        const videoRect = video.getBoundingClientRect();
        const videoAspect = video.videoWidth / video.videoHeight;
        const displayAspect = videoRect.width / videoRect.height;
        let scaleX, scaleY, offsetX, offsetY;
        if (videoAspect > displayAspect) {
          scaleY = video.videoHeight / videoRect.height;
          scaleX = scaleY;
          const scaledVideoWidth = video.videoWidth / scaleX;
          offsetX = (scaledVideoWidth - videoRect.width) / 2;
          offsetY = 0;
        } else {
          scaleX = video.videoWidth / videoRect.width;
          scaleY = scaleX;
          const scaledVideoHeight = video.videoHeight / scaleY;
          offsetX = 0;
          offsetY = (scaledVideoHeight - videoRect.height) / 2;
        }
        const frameX = frameRect.left - videoRect.left + offsetX;
        const frameY = frameRect.top - videoRect.top + offsetY;
        const frameWidth = frameRect.width;
        const frameHeight = frameRect.height;
        const frameLeft = frameX * scaleX;
        const frameTop = frameY * scaleY;
        const frameRight = (frameX + frameWidth) * scaleX;
        const frameBottom = (frameY + frameHeight) * scaleY;

        documentDetected = false;
        for (let i = 0; i < contours.size(); i++) {
          let contour = contours.get(i);
          // Проверяем, что контур находится внутри рамки
          let boundRect = cv.boundingRect(contour);
          let isInsideFrame =
            boundRect.x >= frameLeft &&
            boundRect.y >= frameTop &&
            boundRect.x + boundRect.width <= frameRight &&
            boundRect.y + boundRect.height <= frameBottom;

          if (isInsideFrame) {
            documentDetected = true;
            console.log("Контур обнаружен внутри рамки");
            contour.delete();
            break;
          }
          contour.delete();
        }

        frame.classList.toggle("detected", documentDetected);
        captureButton.classList.toggle("disabled", !documentDetected);
        statusEl.textContent = documentDetected
          ? "Документ обнаружен, нажмите для снимка"
          : "Поместите документ в пределах белой рамки";

        src.delete();
        gray.delete();
        blurred.delete();
        edges.delete();
        contours.delete();
        hierarchy.delete();
      }

      function startDocumentDetection() {
        function loop() {
          if (videoContainer.style.display === "flex") {
            detectDocument();
            requestAnimationFrame(loop);
          }
        }
        requestAnimationFrame(loop);
      }

      function takePhoto() {
        if (!documentDetected) {
          statusEl.textContent = "Документ не помещается в рамку";
          console.log("Снимок заблокирован: документ не обнаружен");
          return;
        }

        console.log("Снимок");
        resetInactivityTimer();

        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");

        const videoWidth = video.videoWidth;
        const videoHeight = video.videoHeight;
        const frameRect = frame.getBoundingClientRect();
        const videoRect = video.getBoundingClientRect();

        const videoAspect = videoWidth / videoHeight;
        const displayAspect = videoRect.width / videoRect.height;

        let scaleX, scaleY, offsetX, offsetY;
        if (videoAspect > displayAspect) {
          scaleY = videoHeight / videoRect.height;
          scaleX = scaleY;
          const scaledVideoWidth = videoWidth / scaleX;
          offsetX = (scaledVideoWidth - videoRect.width) / 2;
          offsetY = 0;
        } else {
          scaleX = video.videoWidth / videoRect.width;
          scaleY = scaleX;
          const scaledVideoHeight = videoHeight / scaleY;
          offsetX = 0;
          offsetY = (scaledVideoHeight - videoRect.height) / 2;
        }

        const cropX = offsetX * scaleX;
        const cropY = offsetY * scaleY;
        const cropWidth = videoRect.width * scaleX;
        const cropHeight = videoRect.height * scaleY;

        canvas.width = cropWidth;
        canvas.height = cropHeight;

        ctx.drawImage(
          video,
          cropX,
          cropY,
          cropWidth,
          cropHeight,
          0,
          0,
          cropWidth,
          cropHeight
        );

        // Обработка пикселей: заменяем цвета темнее #555555 на #000000
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
          const r = data[i];
          const g = data[i + 1];
          const b = data[i + 2];
          if (r < 85 && g < 85 && b < 85) {
            data[i] = 0;     // R
            data[i + 1] = 0; // G
            data[i + 2] = 0; // B
            // data[i + 3] — альфа, не трогаем
          }
        }
        ctx.putImageData(imageData, 0, 0);

        const imageDataUrl = canvas.toDataURL("image/jpeg", 1.0);
        previewImage.src = imageDataUrl;

        canvas.toBlob((blob) => {
          const url = URL.createObjectURL(blob);
          downloadButton.href = url;
          downloadButton.download = "captured-photo.jpg";
          console.log("Фото сохранено");
        }, "image/jpeg", 1.0);

        videoContainer.style.display = "none";
        previewContainer.style.display = "flex";
        statusEl.textContent = "Документ принят на рассмотрение";
      }

      function retakePhoto() {
        console.log("Пересъемка");
        resetInactivityTimer();
        previewImage.src = "";
        downloadButton.href = "#";
        previewContainer.style.display = "none";
        videoContainer.style.display = "flex";
        statusEl.textContent = "Поместите документ в пределах белой рамки";
        captureButton.classList.add("disabled");
      }
    </script>
  </body>
</html>
