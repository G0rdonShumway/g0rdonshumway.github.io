<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>Верификация документа</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, viewport-fit=cover"
    />
    <!-- Подключаем OpenCV.js -->
    <script async src="https://docs.opencv.org/4.5.5/opencv.js" onload="onOpenCvReady()"></script>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div id="launchContainer">
      <button onclick="startCamera()">Запустить камеру</button>
    </div>

    <div id="videoContainer">
      <div id="status">Поместите документ в пределах белой рамки</div>
      <video id="video" autoplay playsinline></video>
      <div id="overlay-darken"></div>
      <div id="frame"></div>
      <div id="buttons">
        <button class="btn-switch" onclick="switchCamera()"></button>
        <button class="btn-circle" onclick="takePhoto()"></button>
      </div>
    </div>

    <div id="previewContainer">
      <img id="previewImage" alt="Preview" />
      <a id="downloadButton" href="#" download="captured-photo.jpg">Скачать фото</a>
      <button id="redoButton" onclick="retakePhoto()">Переделать снимок</button>
    </div>

    <script>
      let stream;
      let currentFacingMode = "environment";
      const video = document.getElementById("video");
      const frame = document.getElementById("frame");
      const launchContainer = document.getElementById("launchContainer");
      const videoContainer = document.getElementById("videoContainer");
      const previewContainer = document.getElementById("previewContainer");
      const previewImage = document.getElementById("previewImage");
      const statusEl = document.getElementById("status");
      const downloadButton = document.getElementById("downloadButton");
      let openCvLoaded = false;
      let documentDetected = false;
      const requireDetection = true; // Установите false, чтобы отключить проверку автообнаружения

      // Проверяем загрузку OpenCV.js
      function onOpenCvReady() {
        openCvLoaded = true;
        console.log("OpenCV.js загружен");
        startDocumentDetection();
      }

      async function startCamera(facingModeInput) {
        console.log("Запуск камеры с facingMode:", facingModeInput);
        const facingMode =
          facingModeInput || currentFacingMode || "environment";
        if (stream) stream.getTracks().forEach((track) => track.stop());
        try {
          stream = await navigator.mediaDevices.getUserMedia({
            video: {
              facingMode,
              width: { ideal: 3840 },
              height: { ideal: 2160 },
            },
            audio: false,
          });
          video.srcObject = stream;
          videoContainer.style.display = "flex";
          launchContainer.style.display = "none";
          previewContainer.style.display = "none";
          statusEl.textContent = "Поместите документ в пределах белой рамки";
          currentFacingMode = facingMode;

          await new Promise((resolve) => {
            video.onloadedmetadata = () => resolve();
          });

          if (openCvLoaded) startDocumentDetection();
        } catch (err) {
          console.warn("Ошибка камеры:", err);
          if (
            facingMode === "environment" &&
            err.name === "OverconstrainedError"
          ) {
            return startCamera("user");
          }
          statusEl.textContent = "Ошибка запуска камеры: " + err.message;
        }
      }

      function switchCamera() {
        console.log("Переключение камеры");
        const nextMode = currentFacingMode === "user" ? "environment" : "user";
        startCamera(nextMode);
      }

      function detectDocument() {
        if (!openCvLoaded) {
          console.log("OpenCV.js еще не загружен, пропускаем детекцию");
          return;
        }

        const canvas = document.createElement("canvas");
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

        let src = cv.imread(canvas);
        let gray = new cv.Mat();
        let blurred = new cv.Mat();
        let edges = new cv.Mat();
        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();

        // Конвертируем в оттенки серого
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
        // Размытие для подавления шума
        cv.GaussianBlur(gray, blurred, new cv.Size(3, 3), 0);
        // Детекция краев с мягкими порогами
        cv.Canny(blurred, edges, 30, 100);
        // Находим контуры
        cv.findContours(
          edges,
          contours,
          hierarchy,
          cv.RETR_EXTERNAL,
          cv.CHAIN_APPROX_SIMPLE
        );

        documentDetected = false;
        for (let i = 0; i < contours.size(); i++) {
          let contour = contours.get(i);
          let perimeter = cv.arcLength(contour, true);
          let approx = new cv.Mat();
          cv.approxPolyDP(contour, approx, 0.05 * perimeter, true);

          let area = cv.contourArea(contour);
          let rect = cv.minAreaRect(contour);
          let aspectRatio = rect.size.width / rect.size.height;
          if (aspectRatio < 1) aspectRatio = 1 / aspectRatio;

          console.log(
            `Контур ${i}: вершин=${approx.rows}, площадь=${area}, соотношение сторон=${aspectRatio.toFixed(2)}`
          );

          // Проверяем площадь и соотношение сторон
          if (area > 2000 && aspectRatio >= 1.0 && aspectRatio <= 3.0) {
            // Если вершин около 4 (3–6), или охватывающий прямоугольник подходит
            if (
              approx.rows >= 3 &&
              approx.rows <= 6 &&
              area > 2000
            ) {
              documentDetected = true;
              console.log(
                `Документ обнаружен: вершин=${approx.rows}, площадь=${area}, соотношение сторон=${aspectRatio.toFixed(2)}`
              );
              break;
            }
          } else {
            console.log(
              `Контур отклонен: площадь=${area}, соотношение сторон=${aspectRatio.toFixed(2)}`
            );
          }

          approx.delete();
          contour.delete();
        }

        frame.classList.toggle("detected", documentDetected);
        statusEl.textContent = documentDetected
          ? "Документ обнаружен, нажмите для снимка"
          : "Поместите документ в пределах белой рамки";

        src.delete();
        gray.delete();
        blurred.delete();
        edges.delete();
        contours.delete();
        hierarchy.delete();
      }

      function startDocumentDetection() {
        console.log("Запуск детекции документа");
        function loop() {
          if (videoContainer.style.display === "flex") {
            detectDocument();
            requestAnimationFrame(loop);
          }
        }
        requestAnimationFrame(loop);
      }

      function takePhoto() {
        console.log("Кнопка съемки нажата, documentDetected:", documentDetected);
        // if (requireDetection && !documentDetected) {
        //   statusEl.textContent = "Документ не обнаружен, попробуйте снова";
        //   console.log("Снимок заблокирован: документ не обнаружен");
        //   return;
        // }

        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");

        const videoWidth = video.videoWidth;
        const videoHeight = video.videoHeight;
        const frameRect = frame.getBoundingClientRect();
        const videoRect = video.getBoundingClientRect();

        const videoAspect = videoWidth / videoHeight;
        const displayAspect = videoRect.width / videoRect.height;

        let scaleX, scaleY, offsetX, offsetY;
        if (videoAspect > displayAspect) {
          scaleY = videoHeight / videoRect.height;
          scaleX = scaleY;
          const scaledVideoWidth = videoWidth / scaleX;
          offsetX = (scaledVideoWidth - videoRect.width) / 2;
          offsetY = 0;
        } else {
          scaleX = videoWidth / videoRect.width;
          scaleY = scaleX;
          const scaledVideoHeight = videoHeight / scaleY;
          offsetX = 0;
          offsetY = (scaledVideoHeight - videoRect.height) / 2;
        }

        const cropX = offsetX * scaleX;
        const cropY = offsetY * scaleY;
        const cropWidth = videoRect.width * scaleX;
        const cropHeight = videoRect.height * scaleY;

        canvas.width = cropWidth;
        canvas.height = cropHeight;

        ctx.drawImage(
          video,
          cropX,
          cropY,
          cropWidth,
          cropHeight,
          0,
          0,
          cropWidth,
          cropHeight
        );

        // Используем исходное изображение без обработки
        const imageData = canvas.toDataURL("image/jpeg", 1.0);
        previewImage.src = imageData;

        canvas.toBlob((blob) => {
          const url = URL.createObjectURL(blob);
          downloadButton.href = url;
          downloadButton.download = "captured-photo.jpg";
          console.log("Blob создан, готов для скачивания");
        }, "image/jpeg", 1.0);

        videoContainer.style.display = "none";
        previewContainer.style.display = "flex";
        statusEl.textContent = "Документ принят на рассмотрение";
      }

      function retakePhoto() {
        console.log("Пересъемка");
        previewImage.src = "";
        downloadButton.href = "#";
        previewContainer.style.display = "none";
        videoContainer.style.display = "flex";
        statusEl.textContent = "Поместите документ в пределах белой рамки";
      }
    </script>
  </body>
</html>
